📦 CARGA-IA - Mensageria com RabbitMQ
Este projeto demonstra um sistema de mensageria assíncrono utilizando RabbitMQ para orquestrar o processamento de diferentes tipos de cargas de trabalho, simulando um ambiente de Inteligência Artificial.

O sistema é composto por:

Um gerador de mensagens: Publica tarefas em uma fila.

Dois consumidores especializados: Cada um processa um tipo específico de mensagem (rosto ou tempo).

Tudo containerizado com Docker e orquestrado com Docker Compose para facilitar a execução.

🚀 Tecnologias Utilizadas
Docker & Docker Compose

RabbitMQ 3.9 (com Management Plugin)

Java 11 (Adoptium)

Maven 3.x

🛠️ Pré-requisitos
Antes de começar, garanta que você tenha as seguintes ferramentas instaladas em sua máquina:

Docker

Docker Compose

Java 11+ (JDK)

Apache Maven

⚙️ Como Executar
Siga os passos abaixo para colocar o ambiente no ar.

1. Clone o repositório:

Bash

git clone https://github.com/seu-repo/CARGA-IA.git
cd CARGA-IA
2. Compile os módulos e gere os JARs:
Este comando irá compilar todos os módulos Java (gerador-mensagens, consumidor-face, consumidor-time).

Bash

mvn clean package
3. Suba os containers:
O Docker Compose irá construir as imagens e iniciar todos os serviços em background (-d).

Bash

docker-compose up --build -d
4. Verifique se os containers estão ativos:

Bash

docker ps
A saída esperada deve ser semelhante a esta:

              NAME                           COMMAND                  STATUS          PORTS
-----------------------------------------------------------------------------------------------------------
carga-ia-consumidor-face-1       "java -jar app.jar"      Up              
carga-ia-consumidor-time-1       "java -jar app.jar"      Up              
carga-ia-gerador-mensagens-1     "java -jar app.jar"      Up              
rabbitmq                         "docker-entrypoint.s…"   Up      0.0.0.0:5672->5672/tcp, 0.0.0.0:15672->15672/tcp
5. Monitore os logs dos consumidores (Opcional):
Para ver as mensagens sendo processadas em tempo real, use o comando abaixo:

Bash

# Para o consumidor de rosto
docker-compose logs -f consumidor-face

# Para o consumidor de tempo
docker-compose logs -f consumidor-time
📊 Painel de Monitoramento (RabbitMQ)
Você pode monitorar as filas, trocas (exchanges), mensagens em trânsito e consumidores conectados através do painel de gerenciamento do RabbitMQ.

URL: http://localhost:15672

Usuário: guest

Senha: guest

📨 Arquitetura e Fluxo de Mensagens
O Gerador de Mensagens publica mensagens em uma exchange do tipo direct chamada ia_exchange. Cada mensagem possui uma routing key (chave de roteamento) que determina para qual fila ela deve ser enviada.

Exchange: ia_exchange (direct)

Filas:

face_queue: Recebe mensagens com a routing key rosto.

time_queue: Recebe mensagens com a routing key tempo.

Consumidores:

consumidor-face: Escuta a fila face_queue.

consumidor-time: Escuta a fila time_queue.

Snippet de código

graph TD
    A[Gerador de Mensagens] -- Manda msg com routing key 'rosto' --> B(Exchange: ia_exchange);
    A -- Manda msg com routing key 'tempo' --> B;
    B -- routing key: 'rosto' --> C[Fila: face_queue];
    B -- routing key: 'tempo' --> D[Fila: time_queue];
    C --> E[Consumidor Face];
    D --> F[Consumidor Time];
💻 Exemplos de Código
Abaixo estão exemplos simplificados de como o produtor envia e como um consumidor recebe uma mensagem.

Produtor (Gerador de Mensagens)
Java

// Pacote: gerador-mensagens

import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;

public class MessageProducer {
    private final static String EXCHANGE_NAME = "ia_exchange";

    public void sendMessage(String routingKey, String message) throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("rabbitmq"); // Nome do serviço no docker-compose

        try (Connection connection = factory.newConnection();
             Channel channel = connection.createChannel()) {
            
            channel.exchangeDeclare(EXCHANGE_NAME, "direct");
            
            channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes("UTF-8"));
            System.out.println(" [x] Enviada '" + routingKey + "':'" + message + "'");
        }
    }
}
Consumidor (Ex: Consumidor de Rosto)
Java

// Pacote: consumidor-face

import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.Channel;
import com.rabbitmq.client.DeliverCallback;

public class MessageConsumer {
    private final static String EXCHANGE_NAME = "ia_exchange";
    private final static String QUEUE_NAME = "face_queue";

    public void startListening() throws Exception {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost("rabbitmq");

        Connection connection = factory.newConnection();
        Channel channel = connection.createChannel();

        channel.exchangeDeclare(EXCHANGE_NAME, "direct");
        channel.queueDeclare(QUEUE_NAME, true, false, false, null);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "rosto"); // Binding com a routing key

        System.out.println(" [*] Aguardando mensagens de rosto. Para sair, pressione CTRL+C");

        DeliverCallback deliverCallback = (consumerTag, delivery) -> {
            String message = new String(delivery.getBody(), "UTF-8");
            System.out.println(" [x] Recebida: '" + message + "'");
            // Lógica de processamento de rosto aqui...
        };
        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> { });
    }
}

🛑 Parando a Aplicação
Para parar e remover todos os containers relacionados ao projeto:

Bash

docker-compose down
Este comando também removerá a rede criada pelo Docker Compose.
